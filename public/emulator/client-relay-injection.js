/*
 * ‚ö†Ô∏è  AUTO-GENERATED FILE - DO NOT EDIT ‚ö†Ô∏è
 * 
 * This file was automatically generated by 'beemi test' command
 * Generated: 2025-08-24T10:44:14.820Z
 * Source: Beemi Server SDK Manifest
 * 
 * Manual changes to this file will be lost when running 'beemi test'
 * To customize emulator behavior, modify your project's manifest.json instead
 */

/**
 * Client Relay Injection Script
 * Injected into each individual emulator to intercept SDK calls and relay them to the multi-client bridge
 */

(function() {
    'use strict';
    
    // Check if we're in multi-client mode
    const urlParams = new URLSearchParams(window.location.search);
    const clientName = urlParams.get('clientName');
    
    if (!clientName) {
        console.log('üîó Single-client mode - no relay injection needed');
        return;
    }
    
    console.log(`üîó ${clientName} - Initializing relay injection...`);
    
    let originalSDK = null;
    let relayActive = false;
    let pendingRequests = new Map();
    let requestIdCounter = 0;
    
    // Wait for SDK to be ready, then intercept
    function waitForSDKAndIntercept() {
        if (window.beemi && window.beemi.multiplayer && window.beemi.multiplayer.room) {
            console.log(`üîó ${clientName} - SDK detected, setting up relay interception`);
            setupSDKInterception();
        } else {
            console.log(`üîó ${clientName} - Waiting for SDK... (beemi: ${!!window.beemi}, multiplayer: ${!!window.beemi?.multiplayer}, room: ${!!window.beemi?.multiplayer?.room})`);
            setTimeout(waitForSDKAndIntercept, 200);
        }
    }
    
    function setupSDKInterception() {
        // Store original SDK methods
        originalSDK = {
            crdt: {
                set: window.beemi.multiplayer.crdt.set,
                get: window.beemi.multiplayer.crdt.get
            },
            room: {
                host: window.beemi.multiplayer.room.host,
                join: window.beemi.multiplayer.room.join,
                leave: window.beemi.multiplayer.room.leave,
                getState: window.beemi.multiplayer.room.getState
            },
            on: window.beemi.multiplayer.on,
            isLeader: window.beemi.multiplayer.isLeader
        };

        // Initialize with a default room state so getState() doesn't return null
        window.multiClientRoomState = {
            roomId: 'emulator-room',
            playerId: window.BEEMI_USER_ID || 'unknown',
            playerName: clientName,
            isLeader: false,
            isConnected: false,
            playerCount: 0,
            players: [],
            gameId: 'spy',
            joinCode: null,
            status: 'waiting'
        };
        
        console.log(`üè† ${clientName} - Default room state initialized:`, window.multiClientRoomState);
        
        // Intercept CRDT operations
        window.beemi.multiplayer.crdt.set = function(key, value) {
            console.log(`üìù ${clientName} CRDT SET: ${key} =`, value);
            
            // Send to multi-client bridge
            sendToMultiClientBridge({
                type: 'crdt-set-request',
                key: key,
                value: value
            });
            
            return Promise.resolve();
        };
        
        window.beemi.multiplayer.crdt.get = function(key) {
            console.log(`üìñ ${clientName} CRDT GET: ${key}`);
            
            // For now, return from local cache or null
            // In full implementation, this would be synchronous from shared state
            return null;
        };
        
        // Store local room state for this client
        window.multiClientRoomState = null;
        
        // Intercept room operations
        window.beemi.multiplayer.room.host = function(gameId) {
            console.log(`üè† ${clientName} ROOM HOST: ${gameId}`);
            
            // Set local room state immediately
            window.multiClientRoomState = {
                roomId: 'multi-room',
                playerId: window.BEEMI_USER_ID || 'unknown',
                playerName: clientName,
                isLeader: true,
                isConnected: true,
                playerCount: 1,
                gameId: gameId,
                joinCode: 'MULTI',
                status: 'active'
            };
            
            sendToMultiClientBridge({
                type: 'room-host-request',
                gameId: gameId
            });
            
            return Promise.resolve({ roomId: 'multi-room' });
        };
        
        window.beemi.multiplayer.room.join = function(code) {
            console.log(`üö™ ${clientName} ROOM JOIN: ${code}`);
            
            // Set local room state immediately
            window.multiClientRoomState = {
                roomId: 'multi-room',
                playerId: window.BEEMI_USER_ID || 'unknown',
                playerName: clientName,
                isLeader: false,
                isConnected: true,
                playerCount: 2, // Will be updated by bridge
                gameId: 'spy',
                joinCode: code,
                status: 'active'
            };
            
            sendToMultiClientBridge({
                type: 'room-join-request',
                code: code
            });
            
            return Promise.resolve({ roomId: 'multi-room' });
        };
        
        window.beemi.multiplayer.room.leave = function() {
            console.log(`üö∂ ${clientName} ROOM LEAVE`);
            
            // Clear local room state
            window.multiClientRoomState = null;
            
            sendToMultiClientBridge({
                type: 'room-leave-request'
            });
            
            return Promise.resolve();
        };

        // Intercept getState to return local room state
        window.beemi.multiplayer.room.getState = function() {
            console.log(`üìñ ${clientName} ROOM GET STATE:`, window.multiClientRoomState);
            return window.multiClientRoomState;
        };
        
        // Intercept event subscriptions
        window.beemi.multiplayer.on = function(event, callback) {
            console.log(`üì° ${clientName} EVENT SUB: ${event}`);
            
            // Store callback locally
            if (!window.multiClientEventCallbacks) {
                window.multiClientEventCallbacks = new Map();
            }
            
            if (!window.multiClientEventCallbacks.has(event)) {
                window.multiClientEventCallbacks.set(event, []);
            }
            
            window.multiClientEventCallbacks.get(event).push(callback);
            
            // Notify bridge about subscription
            sendToMultiClientBridge({
                type: 'event-subscription',
                event: event,
                callbackId: Date.now()
            });
        };
        
        // Intercept isLeader check
        window.beemi.multiplayer.isLeader = function() {
            // This will be updated by the multi-client bridge
            return window.BEEMI_IS_LEADER || false;
        };
        
        relayActive = true;
        console.log(`‚úÖ ${clientName} - Relay interception active`);
    }
    
    // Send message to multi-client bridge
    function sendToMultiClientBridge(data) {
        try {
            window.parent.postMessage({
                type: 'multi-client-relay',
                clientId: window.BEEMI_CLIENT_ID || clientName,
                data: data,
                timestamp: Date.now()
            }, '*');
        } catch (error) {
            console.error(`‚ùå ${clientName} - Failed to send to bridge:`, error);
        }
    }
    
    // Listen for messages from multi-client bridge
    window.addEventListener('message', function(event) {
        if (event.data.type === 'multi-client-response') {
            handleBridgeResponse(event.data);
        }
    });
    
    // Handle responses from multi-client bridge
    function handleBridgeResponse(data) {
        switch (data.responseType) {
            case 'crdt-update':
                handleCRDTUpdate(data.key, data.value, data.source);
                break;
                
            case 'multiplayer-event':
                handleMultiplayerEvent(data.event, data.eventData);
                break;
                
            case 'leader-status':
                window.BEEMI_IS_LEADER = data.isLeader;
                // Update room state if we have one
                if (window.multiClientRoomState) {
                    window.multiClientRoomState.isLeader = data.isLeader;
                }
                console.log(`üëë ${clientName} - Leader status: ${data.isLeader}`);
                break;
                
            case 'room-state-update':
                updateRoomState(data.roomState);
                break;
        }
    }
    
    // Update local room state from bridge
    function updateRoomState(newRoomState) {
        console.log(`üè† ${clientName} - Room state update:`, newRoomState);
        window.multiClientRoomState = newRoomState;
    }
    
    // Handle CRDT updates from other clients
    function handleCRDTUpdate(key, value, source) {
        console.log(`üìù ${clientName} - CRDT UPDATE from ${source}: ${key} =`, value);
        
        // Trigger crdt-update event in the game
        if (window.beemi && window.beemi.core) {
            window.beemi.core.emit('crdt-update', {
                key: key,
                value: value,
                playerId: source
            });
        }
    }
    
    // Handle multiplayer events from bridge
    function handleMultiplayerEvent(event, eventData) {
        console.log(`üéÆ ${clientName} - MULTIPLAYER EVENT: ${event}`, eventData);
        
        // Call registered callbacks
        const callbacks = window.multiClientEventCallbacks?.get(event);
        if (callbacks) {
            callbacks.forEach(callback => {
                try {
                    callback(eventData);
                } catch (error) {
                    console.error(`‚ùå ${clientName} - Error in event callback:`, error);
                }
            });
        }
        
        // Also emit via core event system
        if (window.beemi && window.beemi.core) {
            window.beemi.core.emit(event, eventData);
        }
    }
    
    // Start the interception process
    console.log(`üîó ${clientName} - Starting SDK interception...`);
    waitForSDKAndIntercept();
    
})();
