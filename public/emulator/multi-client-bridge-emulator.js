/*
 * âš ï¸  AUTO-GENERATED FILE - DO NOT EDIT âš ï¸
 * 
 * This file was automatically generated by 'beemi test' command
 * Generated: 2025-08-24T10:44:15.802Z
 * Source: Beemi Server SDK Manifest
 * 
 * Manual changes to this file will be lost when running 'beemi test'
 * To customize emulator behavior, modify your project's manifest.json instead
 */

/**
 * Multi-Client Bridge Emulator
 * Handles communication relay between multiple embedded emulators for multiplayer testing
 * 
 * This script runs in the outer multi-phone emulator and coordinates:
 * - CRDT state synchronization across clients
 * - Room management (host/join/leave)
 * - Player events (join/leave/ready)
 * - Game phase synchronization
 * - Vote tracking and results
 */

class MultiClientBridgeEmulator {
    constructor() {
        this.clients = new Map(); // clientId -> {iframe, userId, user, isLeader}
        this.sharedState = new Map(); // CRDT state storage
        this.roomState = {
            roomId: null,
            leaderId: null,
            isActive: false,
            playerCount: 0
        };
        
        this.messageLog = [];
        this.debug = true;
        
        this.setupMessageListener();
    }

    // Register a client iframe
    registerClient(clientId, iframe, userId, user) {
        const isFirstClient = this.clients.size === 0;
        
        this.clients.set(clientId, {
            id: clientId,
            iframe: iframe,
            userId: userId,
            user: user,
            isLeader: isFirstClient, // First client becomes leader
            isConnected: true // Auto-connect all clients to shared room
        });
        
        // Initialize shared room if this is the first client
        if (isFirstClient) {
            this.roomState = {
                roomId: `multi-client-room-${Date.now()}`,
                leaderId: clientId,
                isActive: true,
                playerCount: 1
            };
        } else {
            this.roomState.playerCount++;
        }
        
        // Start injection process immediately (iframe should already be loaded)
        this.injectRelayIntoClient(clientId);
    }

    // Remove client
    unregisterClient(clientId) {
        const client = this.clients.get(clientId);
        if (client) {
            console.log(`ðŸ“± Unregistered ${clientId} (${client.user.username})`);
            
            // Send player-left event to remaining clients
            this.broadcastToAll({
                type: 'multiplayer-event',
                event: 'player-left',
                data: {
                    playerId: client.userId,
                    playerName: client.user.username,
                    playerCount: this.clients.size - 1,
                    players: this.getPlayerList().filter(p => p.playerId !== client.userId)
                }
            });
            
            this.clients.delete(clientId);
            this.roomState.playerCount = this.clients.size;
            
            // If this was the leader, reassign leadership
            if (client.isLeader && this.clients.size > 0) {
                this.reassignLeadership();
            }
            
            // If no clients left, deactivate room
            if (this.clients.size === 0) {
                this.roomState.isActive = false;
                console.log(`ðŸ  Shared room deactivated - no clients remaining`);
            }
        }
    }

    // Inject complete multiplayer module into client's game iframe
    injectRelayIntoClient(clientId) {
        const client = this.clients.get(clientId);
        if (!client || !client.iframe.contentWindow) {
            console.error(`âŒ Cannot inject into ${clientId} - iframe not ready`);
            return;
        }

        try {
            // Wait for emulator iframe to be ready, then find game iframe
            const waitForEmulatorAndGameIframe = () => {
                try {
                    const emulatorWindow = client.iframe.contentWindow;
                    const gameIframe = emulatorWindow.document.querySelector('.webview-iframe');
                    
                    if (gameIframe && gameIframe.contentWindow) {
                        this.waitForSDKAndInject(clientId, gameIframe.contentWindow);
                    } else {
                        setTimeout(waitForEmulatorAndGameIframe, 500);
                    }
                } catch (error) {
                    setTimeout(waitForEmulatorAndGameIframe, 500);
                }
            };
            
            setTimeout(waitForEmulatorAndGameIframe, 1000); // Give emulator time to load
            
        } catch (error) {
            console.error(`âŒ Error setting up injection for ${clientId}:`, error);
        }
    }

    // Wait for SDK in game iframe and inject complete multiplayer module
    waitForSDKAndInject(clientId, gameWindow) {
        const client = this.clients.get(clientId);
        let attemptCount = 0;
        
        const waitForSDK = () => {
            attemptCount++;
            
            try {
                if (gameWindow.beemi && gameWindow.beemi.core) {
                    // Inject our complete multiplayer module
                    gameWindow.beemi.multiplayer = this.createMultiplayerModule(clientId);
                    
                    // Set client identification
                    gameWindow.BEEMI_CLIENT_ID = clientId;
                    gameWindow.BEEMI_USER_ID = client.userId;
                    gameWindow.BEEMI_IS_LEADER = client.isLeader;
                    
                } else {
                    if (attemptCount < 100) {
                        setTimeout(waitForSDK, 100);
                    } else {
                        console.error(`âŒ [BRIDGE INJECT] SDK never became ready for ${clientId} after 10 seconds`);
                    }
                }
            } catch (error) {
                console.error(`âŒ [BRIDGE INJECT] Error waiting for SDK in ${clientId}:`, error);
                if (attemptCount < 100) {
                    setTimeout(waitForSDK, 100);
                }
            }
        };
        
        waitForSDK();
    }

    // Setup complete multiplayer module for a specific client
    setupClientRelay(clientId, contentWindow) {
        const client = this.clients.get(clientId);
        console.log(`ðŸ”§ Setting up complete multiplayer module for ${clientId} (${client.user.username})`);

        // Inject complete multiplayer module
        contentWindow.beemi.multiplayer = this.createMultiplayerModule(clientId);

        // Inject client identification for debugging
        contentWindow.BEEMI_CLIENT_ID = clientId;
        contentWindow.BEEMI_USER_ID = client.userId;
        contentWindow.BEEMI_IS_LEADER = client.isLeader;

        console.log(`âœ… Complete multiplayer module injected for ${clientId}`);
    }

    // Create complete multiplayer module for a client
    createMultiplayerModule(clientId) {
        const client = this.clients.get(clientId);
        
        return {
            // CRDT operations with real shared state
            crdt: {
                set: (key, value) => {
                    this.log(`ðŸ“ CRDT SET [${clientId}]: ${key} =`, value);
                    this.handleCRDTSet(clientId, key, value);
                    return Promise.resolve();
                },
                get: (key) => {
                    // Try to get from local cache first, then from shared state
                    let value = null;
                    
                    try {
                        const emulatorWindow = client.iframe.contentWindow;
                        const gameIframe = emulatorWindow?.document?.querySelector('.webview-iframe');
                        
                        if (gameIframe && gameIframe.contentWindow && gameIframe.contentWindow.multiClientCRDTCache) {
                            value = gameIframe.contentWindow.multiClientCRDTCache.get(key);
                        }
                    } catch (error) {
                        // Fallback to shared state
                    }
                    
                    if (value === undefined || value === null) {
                        const stateData = this.sharedState.get(key);
                        value = stateData ? stateData.value : null;
                    }
                    
                    this.log(`ðŸ“– CRDT GET [${clientId}]: ${key} = ${JSON.stringify(value)}`);
                    return value;
                },
                watch: (key, callback) => {
                    this.log(`ðŸ‘ï¸ CRDT WATCH [${clientId}]: ${key}`);
                    this.handleCRDTWatch(clientId, key, callback);
                }
            },

            // Room management with real state
            room: {
                host: (gameId) => {
                    this.log(`ðŸ  ROOM HOST [${clientId}]: ${gameId}`);
                    return this.handleRoomHost(clientId, gameId);
                },
                join: (code) => {
                    this.log(`ðŸšª ROOM JOIN [${clientId}]: ${code}`);
                    return this.handleRoomJoin(clientId, code);
                },
                leave: () => {
                    this.log(`ðŸš¶ ROOM LEAVE [${clientId}]`);
                    return this.handleRoomLeave(clientId);
                },
                getState: () => {
                    const state = this.getRoomStateForClient(clientId);
                    this.log(`ðŸ“– ROOM GET STATE [${clientId}]:`, state);
                    return state;
                }
            },

            // Event system with real callbacks
            on: (event, callback) => {
                this.log(`ðŸ“¡ EVENT SUB [${clientId}]: ${event}`);
                this.handleEventSubscription(clientId, event, callback);
            },

            // Leadership status
            isLeader: () => {
                return client.isLeader;
            },

            // Mutex operations (for completeness)
            mutex: {
                acquire: (key) => {
                    this.log(`ðŸ”’ MUTEX ACQUIRE [${clientId}]: ${key}`);
                    return Promise.resolve();
                },
                release: (key) => {
                    this.log(`ðŸ”“ MUTEX RELEASE [${clientId}]: ${key}`);
                    return Promise.resolve();
                }
            }
        };
    }

    // Handle CRDT set operations
    handleCRDTSet(clientId, key, value) {
        const client = this.clients.get(clientId);
        
        this.log(`ðŸ“ CRDT SET [${clientId}]: ${key} =`, value);
        
        // Store in shared state
        this.sharedState.set(key, {
            value: value,
            source: clientId,
            timestamp: Date.now()
        });

        // Update CRDT state in ALL clients (including sender for consistency)
        this.syncCRDTToAllClients(key, value, clientId);

        // Special handling for certain keys
        this.handleSpecialCRDTKeys(clientId, key, value);
    }

    // Sync CRDT state to all clients
    syncCRDTToAllClients(key, value, sourceClientId) {
        console.log(`ðŸ”„ [BRIDGE] Syncing CRDT ${key} to all ${this.clients.size} clients...`);
        
        this.clients.forEach((client, clientId) => {
            try {
                const emulatorWindow = client.iframe.contentWindow;
                const gameIframe = emulatorWindow?.document?.querySelector('.webview-iframe');
                
                console.log(`ðŸ”„ [BRIDGE] Syncing to ${clientId} - gameIframe found:`, !!gameIframe);
                
                if (gameIframe && gameIframe.contentWindow && gameIframe.contentWindow.beemi) {
                    // Update the CRDT state directly in the game
                    const gameWindow = gameIframe.contentWindow;
                    
                    console.log(`ðŸ”„ [BRIDGE] ${clientId} - beemi exists:`, !!gameWindow.beemi);
                    console.log(`ðŸ”„ [BRIDGE] ${clientId} - beemi.core exists:`, !!gameWindow.beemi.core);
                    
                    // Store in a local CRDT cache for this client
                    if (!gameWindow.multiClientCRDTCache) {
                        gameWindow.multiClientCRDTCache = new Map();
                        console.log(`ðŸ”„ [BRIDGE] Created CRDT cache for ${clientId}`);
                    }
                    gameWindow.multiClientCRDTCache.set(key, value);
                    
                    // Emit crdt-update event for the game to handle
                    if (gameWindow.beemi.core) {
                        gameWindow.beemi.core.emit('crdt-update', {
                            key: key,
                            value: value,
                            playerId: sourceClientId
                        });
                        console.log(`âœ… [BRIDGE] Synced CRDT ${key} to ${clientId} and emitted event`);
                    } else {
                        console.error(`âŒ [BRIDGE] No beemi.core for ${clientId}`);
                    }
                    
                    // Trigger watch callbacks for this key
                    this.triggerWatchCallbacks(clientId, key, value);
                } else {
                    console.log(`â³ [BRIDGE] Game iframe not ready for ${clientId}, skipping sync`);
                }
            } catch (error) {
                console.error(`âŒ [BRIDGE] Error syncing CRDT to ${clientId}:`, error);
            }
        });
    }

    // Trigger watch callbacks for a specific client and key
    triggerWatchCallbacks(clientId, key, value) {
        const client = this.clients.get(clientId);
        if (client && client.crdtWatchers && client.crdtWatchers.has(key)) {
            const callbacks = client.crdtWatchers.get(key);
            console.log(`ðŸ‘ï¸ [BRIDGE] Triggering ${callbacks.length} watch callbacks for ${clientId}:${key}`);
            
            callbacks.forEach(callback => {
                try {
                    callback(value);
                } catch (error) {
                    console.error(`âŒ [BRIDGE] Error in watch callback for ${clientId}:${key}:`, error);
                }
            });
        }
    }

    // Handle CRDT get operations
    handleCRDTGet(clientId, key) {
        const stateData = this.sharedState.get(key);
        const value = stateData ? stateData.value : null;
        
        this.log(`ðŸ“– CRDT GET [${clientId}]: ${key} =`, value);
        return value;
    }

    // Handle CRDT watch operations
    handleCRDTWatch(clientId, key, callback) {
        const client = this.clients.get(clientId);
        
        this.log(`ðŸ‘ï¸ CRDT WATCH [${clientId}]: ${key}`);
        
        // Store the watch callback for this client
        if (!client.crdtWatchers) {
            client.crdtWatchers = new Map();
        }
        
        if (!client.crdtWatchers.has(key)) {
            client.crdtWatchers.set(key, []);
        }
        
        client.crdtWatchers.get(key).push(callback);
        
        // Immediately call with current value if it exists
        const currentValue = this.sharedState.get(key)?.value;
        if (currentValue !== undefined && currentValue !== null) {
            setTimeout(() => {
                try {
                    callback(currentValue);
                    this.log(`ðŸ‘ï¸ CRDT WATCH [${clientId}]: ${key} - Called with current value`);
                } catch (error) {
                    console.error(`âŒ Error in CRDT watch callback for ${clientId}:`, error);
                }
            }, 10);
        }
    }

    // Handle room hosting (clients are already in shared room)
    handleRoomHost(clientId, gameId) {
        const client = this.clients.get(clientId);
        
        this.log(`ðŸ  ROOM HOST [${clientId}]: ${gameId} (already in shared room)`);
        
        // Ensure this client is the leader
        this.setLeader(clientId);
        
        // Send room-ready event to all clients
        setTimeout(() => {
            this.broadcastToAll({
                type: 'multiplayer-event',
                event: 'room-ready',
                data: {
                    roomId: this.roomState.roomId,
                    joinCode: 'MULTI',
                    playerCount: this.roomState.playerCount
                }
            });
        }, 100);

        return Promise.resolve({ roomId: this.roomState.roomId });
    }

    // Handle room joining (clients are already in shared room)
    handleRoomJoin(clientId, code) {
        const client = this.clients.get(clientId);
        
        this.log(`ðŸšª ROOM JOIN [${clientId}]: ${code} (already in shared room)`);
        
        // Client is already in the shared room, just confirm connection
        client.isConnected = true;

        // Send player-joined event to all clients
        this.broadcastToAll({
            type: 'multiplayer-event',
            event: 'player-joined',
            data: {
                playerId: client.userId,
                playerName: client.user.username,
                playerCount: this.clients.size,
                players: this.getPlayerList()
            }
        });

        return Promise.resolve({ roomId: this.roomState.roomId });
    }

    // Handle room leaving
    handleRoomLeave(clientId) {
        const client = this.clients.get(clientId);
        
        this.log(`ðŸš¶ ROOM LEAVE [${clientId}]`);
        
        client.isConnected = false;
        this.roomState.playerCount--;

        // Send player-left event to all clients
        this.broadcastToAll({
            type: 'multiplayer-event',
            event: 'player-left',
            data: {
                playerId: client.userId,
                playerName: client.user.username,
                playerCount: this.roomState.playerCount,
                players: this.getPlayerList()
            }
        });

        // Update room state for all remaining clients
        this.updateAllClientRoomStates();

        return Promise.resolve();
    }

    // Handle event subscriptions
    handleEventSubscription(clientId, event, callback) {
        const client = this.clients.get(clientId);
        
        this.log(`ðŸ“¡ EVENT SUB [${clientId}]: ${event}`);
        
        // Store callback for this client and event
        if (!client.eventCallbacks) {
            client.eventCallbacks = new Map();
        }
        
        if (!client.eventCallbacks.has(event)) {
            client.eventCallbacks.set(event, []);
        }
        
        client.eventCallbacks.get(event).push(callback);
    }

    // Handle special CRDT keys that need extra processing
    handleSpecialCRDTKeys(clientId, key, value) {
        switch (key) {
            case 'game-phase':
                this.log(`ðŸŽ¯ PHASE CHANGE [${clientId}]: ${value}`);
                break;
                
            case 'game-players':
                this.log(`ðŸ‘¥ PLAYERS UPDATE [${clientId}]:`, value);
                if (value) {
                    this.roomState.playerCount = Object.keys(value).length;
                }
                break;
                
            case 'player-requests':
                if (value && typeof value === 'object') {
                    this.handlePlayerRequests(clientId, value);
                }
                break;
                
            case 'voting-results':
                this.log(`ðŸ—³ï¸ VOTING RESULTS [${clientId}]:`, value);
                break;
                
            case 'current-word':
                this.log(`ðŸ“ WORD SET [${clientId}]: ${value}`);
                break;
        }
    }

    // Handle player join/leave requests
    handlePlayerRequests(sourceClientId, requests) {
        this.log(`ðŸ“¨ PLAYER REQUESTS [${sourceClientId}]:`, requests);
        
        // Process each request
        Object.keys(requests).forEach(playerId => {
            const request = requests[playerId];
            if (request.type === 'join') {
                this.log(`âœ… Processing join request for player: ${playerId}`);
            } else if (request.type === 'leave') {
                this.log(`âœ… Processing leave request for player: ${playerId}`);
            }
        });
    }

    // Set leader
    setLeader(clientId) {
        // Remove leader status from all clients
        this.clients.forEach(client => {
            client.isLeader = false;
        });
        
        // Set new leader
        const newLeader = this.clients.get(clientId);
        if (newLeader) {
            newLeader.isLeader = true;
            this.roomState.leaderId = clientId;
            
            this.log(`ðŸ‘‘ LEADER SET: ${clientId} (${newLeader.user.username})`);
            
            // Broadcast leader change
            this.broadcastToAll({
                type: 'multiplayer-event',
                event: 'leader-changed',
                data: {
                    newLeaderId: newLeader.userId,
                    oldLeaderId: null
                }
            });
        }
    }

    // Reassign leadership when leader leaves
    reassignLeadership() {
        const availableClients = Array.from(this.clients.values());
        if (availableClients.length > 0) {
            const newLeader = availableClients[0];
            this.setLeader(newLeader.id);
        }
    }

    // Get current player list
    getPlayerList() {
        return Array.from(this.clients.values())
            .filter(client => client.isConnected)
            .map(client => ({
                playerId: client.userId,
                playerName: client.user.username,
                isLeader: client.isLeader
            }));
    }

    // Get room state for a specific client (shared room for all clients)
    getRoomStateForClient(clientId) {
        const client = this.clients.get(clientId);
        if (!client) {
            return null;
        }

        // Always return the same shared room state for all clients
        return {
            roomId: this.roomState.roomId || 'multi-client-room',
            playerId: client.userId,
            playerName: client.user.username,
            isLeader: client.isLeader,
            isConnected: client.isConnected,
            playerCount: this.clients.size, // Total clients, not just connected
            players: this.getPlayerList(),
            gameId: 'spy',
            joinCode: 'MULTI',
            status: this.roomState.isActive ? 'active' : 'ready'
        };
    }

    // Update room state for all connected clients
    updateAllClientRoomStates() {
        this.clients.forEach((client, clientId) => {
            if (client.isConnected) {
                this.sendToClient(clientId, {
                    type: 'multi-client-response',
                    responseType: 'room-state-update',
                    roomState: this.getRoomStateForClient(clientId)
                });
            }
        });
    }

    // Send message to specific client
    sendToClient(clientId, message) {
        const client = this.clients.get(clientId);
        if (!client || !client.iframe.contentWindow) {
            console.error(`âŒ Cannot send to ${clientId} - iframe not ready`);
            return false;
        }

        try {
            // Try direct SDK communication first
            const contentWindow = client.iframe.contentWindow;
            if (contentWindow.beemi && contentWindow.beemi.core) {
                
                // Handle multiplayer events
                if (message.type === 'multiplayer-event') {
                    const eventCallbacks = client.eventCallbacks?.get(message.event);
                    if (eventCallbacks) {
                        eventCallbacks.forEach(callback => {
                            try {
                                callback(message.data);
                            } catch (error) {
                                console.error(`âŒ Error in ${clientId} event callback:`, error);
                            }
                        });
                    }
                    
                    // Also emit via core event system
                    contentWindow.beemi.core.emit(message.event, message.data);
                }
                
                // Handle CRDT updates
                else if (message.type === 'crdt-update') {
                    contentWindow.beemi.core.emit('crdt-update', {
                        key: message.key,
                        value: message.value,
                        playerId: message.source
                    });
                }
                
                return true;
            } else {
                // Fallback to postMessage
                contentWindow.postMessage(message, '*');
                return true;
            }
        } catch (error) {
            console.error(`âŒ Failed to send to ${clientId}:`, error);
            return false;
        }
    }

    // Relay message to all clients except sender
    relayToOthers(excludeClientId, message) {
        this.clients.forEach((client, clientId) => {
            if (clientId !== excludeClientId) {
                this.sendToClient(clientId, message);
            }
        });
    }

    // Broadcast message to all clients
    broadcastToAll(message) {
        this.clients.forEach((client, clientId) => {
            this.sendToClient(clientId, message);
        });
    }

    // Setup message listener for client communications
    setupMessageListener() {
        window.addEventListener('message', (event) => {
            try {
                const data = event.data;
                
                // Find which client sent this message
                let sourceClientId = null;
                this.clients.forEach((client, clientId) => {
                    if (event.source === client.iframe.contentWindow) {
                        sourceClientId = clientId;
                    }
                });

                if (!sourceClientId) {
                    return; // Not from our clients
                }

                this.handleClientMessage(sourceClientId, data);
                
            } catch (error) {
                console.error('âŒ Error handling client message:', error);
            }
        });
    }

    // Handle messages from clients
    handleClientMessage(clientId, data) {
        // Handle the wrapper message format
        if (data.type === 'multi-client-relay') {
            const actualData = data.data;
            const actualClientId = data.clientId || clientId;
            
            switch (actualData.type) {
                case 'crdt-set-request':
                    this.handleCRDTSet(actualClientId, actualData.key, actualData.value);
                    break;
                    
                case 'crdt-get-request':
                    this.respondCRDTGet(actualClientId, actualData.key, actualData.requestId);
                    break;
                    
                case 'room-host-request':
                    this.handleRoomHost(actualClientId, actualData.gameId);
                    break;
                    
                case 'room-join-request':
                    this.handleRoomJoin(actualClientId, actualData.code);
                    break;
                    
                case 'room-leave-request':
                    this.handleRoomLeave(actualClientId);
                    break;
                    
                case 'event-subscription':
                    this.handleEventSubscription(actualClientId, actualData.event, actualData.callbackId);
                    break;
                    
                default:
                    this.log(`â“ Unknown relay message from ${actualClientId}:`, actualData);
            }
        } else {
            this.log(`â“ Unknown message format from ${clientId}:`, data);
        }
    }

    // Respond to CRDT get request
    respondCRDTGet(clientId, key, requestId) {
        const stateData = this.sharedState.get(key);
        const value = stateData ? stateData.value : null;
        
        this.sendToClient(clientId, {
            type: 'crdt-get-response',
            requestId: requestId,
            key: key,
            value: value
        });
    }

        // Utility: Log with timestamp (disabled for cleaner output)
    log(message, ...args) {
        // Disabled to reduce console noise
    }

    // Get debug information
    getDebugInfo() {
        return {
            clients: Array.from(this.clients.entries()).map(([id, client]) => ({
                id: id,
                userId: client.userId,
                username: client.user.username,
                isLeader: client.isLeader,
                isConnected: client.isConnected
            })),
            sharedState: Array.from(this.sharedState.entries()).map(([key, data]) => ({
                key: key,
                value: data.value,
                source: data.source,
                timestamp: data.timestamp
            })),
            roomState: this.roomState,
            messageLog: this.messageLog.slice(-10) // Last 10 messages
        };
    }

    // Bulk actions for testing
    bulkActions = {
        // Make all clients join the room
        allJoinRoom: () => {
            const clients = Array.from(this.clients.values());
            const leader = clients.find(c => c.isLeader);
            const followers = clients.filter(c => !c.isLeader);
            
            if (leader) {
                // Leader hosts first
                this.handleRoomHost(leader.id, 'spy');
                
                // Followers join after delay
                followers.forEach((client, index) => {
                    setTimeout(() => {
                        this.handleRoomJoin(client.id, 'MULTI');
                    }, (index + 1) * 300);
                });
            }
        },

        // Start game from leader
        startGame: () => {
            const leader = Array.from(this.clients.values()).find(c => c.isLeader);
            if (leader) {
                this.handleCRDTSet(leader.id, 'game-phase', 'game-start');
            }
        },

        // Simulate voting phase
        startVoting: () => {
            const leader = Array.from(this.clients.values()).find(c => c.isLeader);
            if (leader) {
                this.handleCRDTSet(leader.id, 'game-phase', 'description-voting');
            }
        },

        // Reset to lobby
        resetToLobby: () => {
            const leader = Array.from(this.clients.values()).find(c => c.isLeader);
            if (leader) {
                this.handleCRDTSet(leader.id, 'game-phase', 'lobby');
            }
        }
    };
}

// Global instance
window.multiClientBridge = new MultiClientBridgeEmulator();

// Helper functions for the multi-phone emulator
window.registerMultiClient = (clientId, iframe, userId, user) => {
    if (window.multiClientBridge) {
        window.multiClientBridge.registerClient(clientId, iframe, userId, user);
    } else {
        console.error(`âŒ Multi-client bridge not available when registering ${clientId}`);
    }
};

window.unregisterMultiClient = (clientId) => {
    window.multiClientBridge.unregisterClient(clientId);
};

window.getMultiClientDebugInfo = () => {
    return window.multiClientBridge.getDebugInfo();
};

// Expose bulk actions
window.multiClientBulkActions = window.multiClientBridge.bulkActions;

// Multi-Client Bridge Emulator loaded and ready
